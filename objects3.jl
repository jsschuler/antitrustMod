# the core challenge is to control the model behavior using structs 
# we have a few structs
# simplest is the agent struct which is alone
# search engines are either hard search engines like Google and Duck Duck Go 
# they are hard coded structs 
# or else they are soft engines which are generated by 
# a function with parameters 

# also, there are structs for laws. 
# we have the data deletion law 
# and the data sharing law 

# finally, and most complex are the action laws. 
# to keep the main model code as simple as possible, 
# there is an action space. 
# an agent acts using the syntax change(move::action,agt::agent)
# thus, there is an action struct for every combination of law and target search engine 
# there is also an action for each search engine, this means switching.
# as agents have memory, there is also a corresponding reverse function with similar syntax 

# every time a new search engine or law is introduced, the action space must be regenerated 
# to account for all combinations

# as a preliminary, define agents 
using Distributions
probType=Union{Uniform{Float64},Beta{Float64}}
# we need a basic agent object
mutable struct agent
    agtNum::Int64
    privacy::Float64
    betaObj::Beta{Float64}
    gammaObj::Gamma{Float64}
    expUnif::Float64
    expSubj::Float64
    blissPoint::Float64
    history::Dict{Int64,Float64}
    currEngine::Any
    prevEngine::Any
    
    
end

# we also need an internet alias as agents can develop different ones 

mutable struct alias
    agt::agent
end

# we need a preliminary set of search objects 

abstract type searchEngine end
# we keep a list of all search engines 
engineList=searchEngine[]

# we now need to subtypes for search engines. 
# hard coded search engines (Google and Duck Duck Go)
# search engines indicated with a privacy parameter
# this parameter how much user data the search engine retains 
# this ranges from 0 (all user date to retained) to 1 (none retained)
# we turn this into 1/(p^k) where k is a constant and p is the privacy parameter

abstract type hardEngine <: searchEngine end
abstract type paramEngine <: searchEngine end

# now hard code the Google search engine 

mutable struct google <: hardEngine
    aliasData::Dict{alias,Array{Float64}}
    usageCount::Dict{Int64,Int64}
end
# and the Duck Duck Go Engine
mutable struct duckDuckGo <: hardEngine
    aliasData::Dict{alias,Array{Float64}}
    usageCount::Dict{Int64,Int64}
end

# also, we need the law structs 

abstract type law end
# we keep a list of all laws
lawList=law[] 

# we need functions to generate search engines and laws 
# and separate functions to generate the space of all actions 

# first the function to generate Google 
function googleGen()
    global engineList
    push!(engineList,google(Dict{alias,Array{Float64}}(),Dict{Int64,Int64}()))
end

# now, the function to generate Duck Duck Go 

function duckGen()
    global engineList
    push!(engineList,duckduckGo(Dict{alias,Array{Float64}}(),Dict{Int64,Int64}()))
end

# finally, a function to generate other search engines
# this is more complex because each gets its own type
# for simplicity, we have a base function that generates the search engine. 
# other functions will call this and also specify the particular behavior 

function otherGen(name)
    string="mutable struct "*name*" <: softEngine aliasData::Dict{alias,Array{Float64}}
        usageCount::Dict{Int64,Int64}
        end"
end

# this must be called through an eval / Meta parse statement  

# now the functions to generate laws.
# we keep track of when they are passed

struct deletion <: law
    available::Int64
end

function deletionGen(t)
    global lawList
    push!(lawList,deletion(t))
end

struct sharing <: law
    available::Int64
end

function sharingGen(t)
    global lawList
    push!(lawList,sharing(t))
end

# finally, actions 

struct action
    law::Union{Nothing,law}
    target::searchEngine
end

actionList=action[]

# now the function that generates actions
# first, we generate all combinations of actions

# we need a quote func

function actQuoteFunc(law,engine)
    # how many actions are there already?
    actCnt=length(subtypes(action))
    law=string(law)
    engine=string(engine)
    quote
        struct action$(esc(string(lawCnt))) <: action
            law::$(esc(law))
            engine::$(esc(engine))
        end
    end
end

function actionCombine()
    global actionList
    actionList=action[]
    # get the list of all current laws
    allLaws::Array{Union{Nothing,law}}=vcat([nothing],substypes(law))
    allEngines::Array{searchEngine}=subtypes(searchEngine)
    # now, an array of quotes
    qArray=[]
    for l in allLaws
        for e in allEngines
            push!(qArray,actQuoteFunc(l,e))
        end
    end
    return qArray
end
# now a macro that generates the objects
macro actionGen()
    quote
        qList=actionCombine()
        for q in qList
            eval(q)
        end
    end
end

# now, we need to generate the functions that allow actions 

# first, a function that generates the code for the actions 
# let's write a few functions that generate quotes based on the law

function switchLaw(act)
    actType=string(typeof(act))
    engineObj=string(typeof(act.target))
    # find the engine object 
    targetEngine=filter(x -> typeof(x)==typeof(act.target),engineList)[1]
    quote 
        function act(move::$(esc(actType)),alias::alias)
            alias.agt.prevEngine=agt.currEngine
            alias.agt.currEngine=targetEngine
        end
    end
end

# this function generates a quoted function for a deletion law
function deleteLaw(act)
    actType=string(typeof(act))
    engineObj=string(typeof(act.target))
    # find the engine object 
    targetEngine=filter(x -> typeof(x)==typeof(act.target),engineList)[1]
    quote
        function act(move::$(esc(actType)),alias::alias)
            move.target.aliasData[alias.agt]=[]
    end
end
# this function generates a quoted function for a data sharing law 


function actQuoteGen()
    # get a list of all search engines 
    global actionList
    qArray=[]
    for act in actionList
        if act.law===nothing
            # we need switching instructions



            push!(qArray,

                )
        else



        end

        
    end
end
